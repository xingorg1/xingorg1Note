# 数据类型与类型转换

## 数据类型
* 字符串  
* 整数
* 浮点数
* 【补充中...】
### 1、字符串 str
字符串：英文string，简写str。
```py
name = '小石头:'
print(name,'2019', '12', '24')
# 小石头: 2019 12 24

print("平安夜，祝你一生平安。Merry Christmas！")
# 平安夜，祝你一生平安。Merry Christmas！
```
以上，包裹在单引号和双引号里边的内容，就是字符串。

换言之，但凡包裹在英文格式下的【单/双/三引号】里的内容，不论引号里边是英文、中文、甚至是数字、符号、火星文等，她都叫做字符串。

* 强调⚠️ 引号！引号！引号！！！

### 2、整数 int
整数：英文为integer，简写做int。
```py
year = 2019
month = -12 # 可以为负数
day = -24 + 12  # 可以做运算
print('Today is',year,month,day)
# Today is 2019 -12 -12
```
以上，2019、12、24这三个都是整数。

没有引号包裹的、没有小数点的、整数数字，就是整数类型。

> 注意⚠️：一旦数字被引号包裹，他就是字符串类型。

### 3、浮点数 float
浮点数: 英文名是float，与整数(int)和字符串(str)不同，

浮点数没有简写。
浮点数非常好识别，它比整数多了一个小数点『. 』。换言之，带小数点的数字即是浮点数。

比如下列代码中的数字都是浮点数。
```py
print(20.19)
# 20.19
print(-12.25) # 可以为负数
# -12.25 
print(520.1314 + 07.11) # 可以做数学运算
# 527.2414
```
> 注意⚠️：同样不能有引号包裹。

> float还有一个计算结果有精度误差的问题。详见下边番外篇。

## 类型查询
* type()函数

## 类型转换
* str()函数
* int()函数
* float()函数

**python是类型严格的语言，不像JS那样的若类型语言，会自动进行类型的隐式转换。所以当不同类型的数据进行结合时，需要我们手动强制进行类型转换。**

强类型语言里，不同类型的数据之间需要进行类型转换才能一起“共事”。

比如，```1+'1'```这么写，在js中肯定没问题，因为会进行隐式类型转换，把数字1变成字符串1，然后就变成了字符串拼接，最后的到11。

但是python不会进行隐式类型转换，他发现你用数字1+字符串1，就会报语法错误。

因此当我们把两个不同类型的数据进行结合处理时，应该手动将其中一方的类型转换统一成跟另一方一样的。

依旧以```1+'1'```为例，进行手动类型转换的方法示例：
```py
a = 1
b = '1'
# print(a + b) 
# # 这么写报错。改正如下：
print(a + int(b)) 
# 2，将字符串转换为int类型，进行加法运算
print(str(a) + b) 
# 11，将整数转为字符串类型，进行字符串拼接。
```

### str()函数
### int()函数
### float()函数



## 数据类型的应用
* 字符串拼接
* 四则运算


## 番外 - 浮点数计算精度问题
运算下边的代码：
```py
print(0.55+0.3)
# 0.8500000000000001
```
发现打印结果并不显而易见的0.85，而是0.8500000000000001。

为什么不是【0.85】，而尾巴多了一个【1】呢？这是因为，Python计算浮点数时，会先把0.55和0.3转化成二进制数【注：二进制数由0和1表示，逢二进一】，如下：
```py
# 进制转换
0.55(十进制) = 0.1000110011001100110011001100110011001100110011001101(二进制)
0.3(十进制) = 0.0100110011001100110011001100110011001100110011001101(二进制)
```
而在这个转化过程中存在误差，这样，就造成了我们与程序计算结果的差异。

然后，这俩二进制数通过二进制法则运算后，再通过复杂的计算公式，将二进制结果转成十进制小数。